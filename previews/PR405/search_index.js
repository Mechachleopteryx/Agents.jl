var documenterSearchIndex = {"docs":
[{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/maze.jl\"","category":"page"},{"location":"examples/maze/#Maze-Solver","page":"Maze Solver","title":"Maze Solver","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../maze.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"Consider a scenario where a walker agent is stuck in a maze. Finding the shortest path through an arbitrary maze or map is simulated using the AStar pathfinder and it's walkable map property.","category":"page"},{"location":"examples/maze/#Setup","page":"Maze Solver","title":"Setup","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"using Agents\nusing FileIO # To load images you also need ImageMagick available to your project","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"The Walker agent needs no special property, just the id and position from @agent.","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"@agent Walker GridAgent{2} begin end","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"The maze is stored as a simple .bmp image, where each pixel corresponds to a position on the grid. White pixels correspond to walkable regions of the maze.","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"function initalize_model(; map_path = \"maze.bmp\")\n    # Load the maze from the image file. White values can be identified by a non-zero red component\n    maze = map(x -> x.r > 0, load(map_path))\n    # The size of the space is the size of the maze\n    space = GridSpace(size(maze); periodic = false)\n    # Create a pathfinder by specifying the `walkable` parameter for the pathfinder.\n    # Since we are interested in the most direct path to the end, the default [`DirectDistance`](@ref)\n    # is appropriate.\n    # `moore_neighbors` is set to `false` to prevent cutting corners by going along diagonals.\n    pathfinder = AStar(space; walkable = maze, moore_neighbors = false)\n    model = ABM(Walker, space, pathfinder)\n    # Place a walker at the start of the maze\n    walker = Walker(1, (1, 4))\n    add_agent_pos!(walker, model)\n    set_target!(walker, (41, 32), model) ## The walker's movement target is the end of the maze\n\n    return model\nend\n\n# Dynamics","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"Stepping the agent is a trivial matter of calling move_agent! to move it along it's path to the target.","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"agent_step!(agent, model) = move_agent!(agent, model)","category":"page"},{"location":"examples/maze/#Visualization","page":"Maze Solver","title":"Visualization","text":"","category":"section"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"Visualizing the Walker move through the maze is handled through InteractiveDynamics.abm_plot.","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"using InteractiveDynamics\nusing GLMakie","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"model = initialise()","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"model = initalize_model(map_path = joinpath(@__DIR__, \"../../../examples/maze.bmp\")) # hide\n\nf, abmstepper =\n    abm_plot(model; resolution = (700, 700), ac = :red, as = 11, offset = _ -> (-0.5, -0.5))\nax = contents(f[1, 1])[1]\nhm = heatmap!(ax, walkmap(model); colormap = :grays)\n\nrecord(f, \"maze.mp4\", 1:310; framerate = 15) do i\n    Agents.step!(abmstepper, model, agent_step!, dummystep, 1)\nend","category":"page"},{"location":"examples/maze/","page":"Maze Solver","title":"Maze Solver","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../maze.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/runners.jl\"","category":"page"},{"location":"examples/runners/#Runners","page":"Runners","title":"Runners","text":"","category":"section"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../runners.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"Let's consider a race to the top of a mountain. Runners have been scattered about a map in some low lying areas and need to find the best path up to the peak.","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"We'll use the AStar pathfinder and a HeightMap to simulate this.","category":"page"},{"location":"examples/runners/#Setup","page":"Runners","title":"Setup","text":"","category":"section"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"using Agents\nusing Random\nusing FileIO # To load images you also need ImageMagick available to your project\n\n@agent Runner GridAgent{2} begin end","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"Our agent, as you can see, is very simple. Just an id and position provided by @agent. The rest of the dynamics of this example will be provided by the model.","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"function initialise(; map_path = \"runners_heightmap.jpg\", goal = (128, 409), seed = 88)\n    # Load an image file and convert it do a simple representation of height\n    heightmap = floor.(Int, convert.(Float64, load(map_path)) * 255)\n    # The space of the model can be obtained directly from the image.\n    # Our example file is (400, 500).\n    space = GridSpace(size(heightmap), periodic = false)\n    # The pathfinder. We use the [`Chebyshev`](@ref) metric since we want the runners\n    # to look for the easiest path to run, not just the most direct.\n    pf = AStar(space; cost_metric = HeightMap(heightmap, Chebyshev))\n    model = ABM(Runner, space, pf; rng = MersenneTwister(seed))\n    for _ in 1:10\n        # Place runners in the low-lying space in the map.\n        runner = add_agent!((rand(model.rng, 100:350), rand(model.rng, 50:200)), model)\n        # Everyone wants to get to the same place.\n        set_target!(runner, goal, model)\n    end\n    return model\nend","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"The example heightmap we use here is a small region of countryside in Sweden, obtained with the Tangram heightmapper.","category":"page"},{"location":"examples/runners/#Dynamics","page":"Runners","title":"Dynamics","text":"","category":"section"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"With the pathfinder in place, and all our runners having a goal position set, stepping is now trivial.","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"agent_step!(agent, model) = move_agent!(agent, model)","category":"page"},{"location":"examples/runners/#Let's-Race","page":"Runners","title":"Let's Race","text":"","category":"section"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"Plotting is simple enough. We just need to use the InteractiveDynamics.abm_plot for our runners, and display the heightmap for our reference. A better interface to do this is currently a work in progress.","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"using InteractiveDynamics\nusing GLMakie","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"model = initialise()","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"model = initialise(map_path = joinpath(@__DIR__, \"../../../examples/runners_heightmap.jpg\")) # hide\nf, abmstepper = abm_plot(\n    model;\n    resolution = (700, 700),\n    ac = :black,\n    as = 8,\n    scatterkwargs = (strokecolor = :white, strokewidth = 2),\n)\nax = contents(f[1, 1])[1]\nax.aspect = DataAspect()\nhm = heatmap!(ax, heightmap(model); colormap = :terrain)\nf[1, 2] = Colorbar(f, hm, width = 30, label = \"Elevation\")\nrowsize!(f.layout, 1, ax.scene.px_area[].widths[2]) # Colorbar height = axis height\n\nrecord(f, \"runners.mp4\", 1:410; framerate = 25) do i\n    Agents.step!(abmstepper, model, agent_step!, dummystep, 1)\nend","category":"page"},{"location":"examples/runners/","page":"Runners","title":"Runners","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../runners.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The API of Agents.jl is defined on top of the fundamental structures  AgentBasedModel, Space, AbstractAgent which are described in the Tutorial page. In this page we list the remaining API functions, which constitute the bulk of Agents.jl functionality.","category":"page"},{"location":"api/#@agent-macro","page":"API","title":"@agent macro","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The @agent macro makes defining agent types within Agents.jl simple.","category":"page"},{"location":"api/","page":"API","title":"API","text":"@agent\nGraphAgent\nGridAgent\nContinuousAgent\nOSMAgent","category":"page"},{"location":"api/#Agents.@agent","page":"API","title":"Agents.@agent","text":"@agent YourAgentType{X, Y} AgentSupertype begin\n    some_property::X\n    other_extra_property::Y\n    # etc...\nend\n\nCreate a struct for your agents which includes the mandatory fields required to operate in a particular space. Depending on the space of your model, the AgentSupertype is chosen appropriately from GraphAgent, GridAgent, ContinuousAgent.\n\nExample\n\nUsing\n\n@agent Person{T} GridAgent{2} begin\n    age::Int\n    moneyz::T\nend\n\nwill in fact create an agent appropriate for using with 2-dimensional GridSpace\n\nmutable struct Person{T} <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Int}\n    age::Int\n    moneyz::T\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#Agents.GraphAgent","page":"API","title":"Agents.GraphAgent","text":"GraphAgent\n\nCombine with @agent to create an agent type for GraphSpace. It attributes the fields id::Int, pos::Int to the start of the agent type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.GridAgent","page":"API","title":"Agents.GridAgent","text":"GridAgent{D}\n\nCombine with @agent to create an agent type for D-dimensional GraphSpace. It attributes the fields id::Int, pos::NTuple{D,Int} to the start of the agent type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.ContinuousAgent","page":"API","title":"Agents.ContinuousAgent","text":"ContinuousAgent{D}\n\nCombine with @agent to create an agent type for D-dimensional ContinuousSpace. It attributes the fields id::Int, pos::NTuple{D,Float64}, vel::NTuple{D,Float64} to the start of the agent type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.OSMAgent","page":"API","title":"Agents.OSMAgent","text":"OSMAgent\n\nCombine with @agent to create an agent type for OpenStreetMapSpace. It attributes the fields id::Int, pos::Tuple{Int,Int,Float64}, route::Vector{Int}, destination::Tuple{Int,Int,Float64} to the start of the agent type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agent/model-retrieval-and-access","page":"API","title":"Agent/model retrieval and access","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"getindex(::ABM, ::Integer)\ngetproperty(::ABM, ::Symbol)\nseed!\nrandom_agent\nnagents\nallagents\nallids","category":"page"},{"location":"api/#Base.getindex-Tuple{AgentBasedModel,Integer}","page":"API","title":"Base.getindex","text":"model[id]\ngetindex(model::ABM, id::Integer)\n\nReturn an agent given its ID.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getproperty-Tuple{AgentBasedModel,Symbol}","page":"API","title":"Base.getproperty","text":"model.prop\ngetproperty(model::ABM, :prop)\n\nReturn a property with name :prop from the current model, assuming the model properties are either a dictionary with key type Symbol or a Julia struct. For example, if a model has the set of properties Dict(:weight => 5, :current => false), retrieving these values can be obtained via model.weight.\n\nThe property names :agents, :space, :scheduler, :properties, :maxid are internals and should not be accessed by the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#Agents.seed!","page":"API","title":"Agents.seed!","text":"seed!(model [, seed])\n\nReseed the random number pool of the model with the given seed or a random one, when using a pseudo-random number generator like MersenneTwister.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_agent","page":"API","title":"Agents.random_agent","text":"random_agent(model) → agent\n\nReturn a random agent from the model.\n\n\n\n\n\nrandom_agent(model, condition) → agent\n\nReturn a random agent from the model that satisfies condition(agent) == true. The function generates a random permutation of agent IDs and iterates through them. If no agent satisfies the condition, nothing is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nagents","page":"API","title":"Agents.nagents","text":"nagents(model::ABM)\n\nReturn the number of agents in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.allagents","page":"API","title":"Agents.allagents","text":"allagents(model)\n\nReturn an iterator over all agents of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.allids","page":"API","title":"Agents.allids","text":"allids(model)\n\nReturn an iterator over all agent IDs of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Available-spaces","page":"API","title":"Available spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here we list the spaces that are available \"out of the box\" from Agents.jl. To create your own, see Creating a new space type.","category":"page"},{"location":"api/#Discrete-spaces","page":"API","title":"Discrete spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"GraphSpace\nGridSpace","category":"page"},{"location":"api/#Agents.GraphSpace","page":"API","title":"Agents.GraphSpace","text":"GraphSpace(graph::AbstractGraph)\n\nCreate a GraphSpace instance that is underlined by an arbitrary graph from LightGraphs.jl. The position type for this space is Int, use GraphAgent for convenience. The underlying graph can be altered using add_node! and rem_node!.\n\nGraphSpace represents a space where each node (i.e. position) of a graph can hold an arbitrary amount of agents, and each agent can move between the nodes of the graph. An example of its usage can be found in SIR model for the spread of COVID-19. If you want to model social networks, where each agent is equivalent with a node of a graph, you're better of using nothing (or other spaces) as the model space, and using a graph from LightGraphs.jl directly in the model parameters, as shown in the Social networks with LightGraphs.jl integration example.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.GridSpace","page":"API","title":"Agents.GridSpace","text":"GridSpace(d::NTuple{D, Int}; periodic = true, metric = :chebyshev)\n\nCreate a GridSpace that has size given by the tuple d, having D ≥ 1 dimensions. Optionally decide whether the space will be periodic and what will be the distance metric used, which decides the behavior of e.g. nearby_ids. The position type for this space is NTuple{D, Int}, use GridAgent for convenience. In our examples we typically use Dims{D} instead of NTuple{D, Int} (they are equivalent). Valid positions have indices in the range 1:d[i] for the ith dimension.\n\n:chebyshev metric means that the r-neighborhood of a position are all positions within the hypercube having side length of 2*floor(r) and being centered in the origin position.\n\n:euclidean metric means that the r-neighborhood of a position are all positions whose cartesian indices have Euclidean distance ≤ r from the cartesian index of the given position.\n\nAn example using GridSpace is the Forest fire model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Continuous-spaces","page":"API","title":"Continuous spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ContinuousSpace\nOpenStreetMapSpace","category":"page"},{"location":"api/#Agents.ContinuousSpace","page":"API","title":"Agents.ContinuousSpace","text":"ContinuousSpace(extent::NTuple{D, <:Real}, spacing = min(extent...)/10; kwargs...)\n\nCreate a D-dimensional ContinuousSpace in range 0 to (but not including) extent. spacing configures the compartment spacing that the space is divided in, in order to accelerate nearest neighbor functions like nearby_ids. All dimensions in extent must be completely divisible by spacing (i.e. no fractional remainder). Your agent positions (field pos) must be of type NTuple{D, <:Real}, use ContinuousAgent for convenience. In addition it is useful for agents to have a field vel::NTuple{D, <:Real} to use in conjunction with move_agent!.\n\nThe keyword periodic = true configures whether the space is periodic or not. If set to false an error will occur if an agent's position exceeds the boundary.\n\nThe keyword argument update_vel! is a function, update_vel!(agent, model) that updates the agent's velocity before the agent has been moved, see move_agent!. You can of course change the agents' velocities during the agent interaction, the update_vel! functionality targets spatial force fields acting on the agents individually (e.g. some magnetic field). By default no update is done this way. If you use update_vel!, the agent type must have a field vel::NTuple{D, <:Real}.\n\nThere is no \"best\" choice for the value of spacing. If you need optimal performance it's advised to set up a benchmark over a range of choices. The value matters most when searching for neighbors. In Models.flocking for example, an optimal value for spacing is 66% of the search distance.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.OpenStreetMapSpace","page":"API","title":"Agents.OpenStreetMapSpace","text":"OpenStreetMapSpace(path::AbstractString; kwargs...)\n\nCreate a space residing on the Open Street Map (OSM) file provided via path.\n\nThe abbreviation OSMSpace may be used interchangeably.\n\nMuch of the functionality of this space is provided by interfacing with OpenStreetMapX.jl, for example the two keyword arguments use_cache = false and trim_to_connected_graph = true can be passed into the OpenStreetMapX.get_map_data function.\n\nFor details on how to obtain an OSM file for your use case, consult the OpenStreetMapX.jl README. We provide a variable TEST_MAP to use as a path for testing.\n\nThis space represents the underlying map as a continuous entity choosing accuracy over performance. An example of its usage can be found in Zombie Outbreak.\n\nIf your solution can tolerate routes to and from intersections only, a faster implementation can be achieved by using the graph representation of your map provided by OpenStreetMapX.jl. For tips on how to implement this, see our integration example: Social networks with LightGraphs.jl.\n\nThe OSMAgent\n\nThe base properties for an agent residing on an OSMSpace are as follows:\n\nmutable struct OSMAgent <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int,Float64}\n    route::Vector{Int}\n    destination::Tuple{Int,Int,Float64}\nend\n\nCurrent position and destination tuples are represented as (start intersection index, finish intersection index, distance travelled in meters). The route is an ordered list of intersections, providing a path to reach destination.\n\nFurther details can be found in OSMAgent.\n\nRouting\n\nThere are two ways to generate a route, depending on the situation.\n\nosm_plan_route, which provides :shortest and :fastest paths (with the option of a return_trip) between intersections or positions.\nosm_random_route!, choses a new destination an plans a new path to it; overriding the current route (if any).\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-agent-interaction","page":"API","title":"Model-agent interaction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following API is mostly universal across all types of Space. Only some specific methods are exclusive to a specific type of space, but these are described further below in this page.","category":"page"},{"location":"api/#Adding-agents","page":"API","title":"Adding agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"add_agent!\nadd_agent_pos!\nnextid\nrandom_position","category":"page"},{"location":"api/#Agents.add_agent!","page":"API","title":"Agents.add_agent!","text":"add_agent!(agent::AbstractAgent [, pos], model::ABM) → agent\n\nAdd the agent to the model in the given position. If pos is not given, the agent is added to a random position. The agent's position is always updated to match position, and therefore for add_agent! the position of the agent is meaningless. Use add_agent_pos! to use the agent's position.\n\nThe type of pos must match the underlying space position type.\n\n\n\n\n\nadd_agent!([pos,] model::ABM, args...; kwargs...) → newagent\n\nCreate and add a new agent to the model by constructing an agent of the type of the model. Propagate all extra positional arguments and keyword arguemts to the agent constructor. Optionally provide a position to add the agent to as first argument, which must match the space position type.\n\nNotice that this function takes care of setting the agent's id and position and thus args... and kwargs... are propagated to other fields the agent has (see example below).\n\nadd_agent!([pos,] A, model::ABM, args...; kwargs...) → newagent\n\nUse this version for mixed agent models, with A the agent type you wish to create (to be called as A(id, pos, args...; kwargs...)), because it is otherwise not possible to deduce a constructor for A.\n\nExample\n\nusing Agents\nmutable struct Agent <: AbstractAgent\n    id::Int\n    pos::Int\n    w::Float64\n    k::Bool\nend\nAgent(id, pos; w=0.5, k=false) = Agent(id, pos, w, k) # keyword constructor\nmodel = ABM(Agent, GraphSpace(complete_digraph(5)))\n\nadd_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally\nadd_agent!(model, 0.5, true) # correct: w becomes 0.5\nadd_agent!(5, model, 0.5, true) # add at position 5, w becomes 0.5\nadd_agent!(model; w = 0.5) # use keywords: w becomes 0.5, k becomes false\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_pos!","page":"API","title":"Agents.add_agent_pos!","text":"add_agent_pos!(agent::AbstractAgent, model::ABM) → agent\n\nAdd the agent to the model at the agent's own position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nextid","page":"API","title":"Agents.nextid","text":"nextid(model::ABM) → id\n\nReturn a valid id for creating a new agent with it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_position","page":"API","title":"Agents.random_position","text":"random_position(model) → pos\n\nReturn a random position in the model's space (always with appropriate Type).\n\n\n\n\n\n","category":"function"},{"location":"api/#Removing-agents","page":"API","title":"Removing agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"kill_agent!\ngenocide!\nsample!","category":"page"},{"location":"api/#Agents.kill_agent!","page":"API","title":"Agents.kill_agent!","text":"kill_agent!(agent::AbstractAgent, model::ABM)\nkill_agent!(id::Int, model::ABM)\n\nRemove an agent from the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.genocide!","page":"API","title":"Agents.genocide!","text":"genocide!(model::ABM)\n\nKill all the agents of the model.\n\n\n\n\n\ngenocide!(model::ABM, n::Int)\n\nKill the agents of the model whose IDs are larger than n.\n\n\n\n\n\ngenocide!(model::ABM, f::Function)\n\nKill all agents where the function f(agent) returns true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.sample!","page":"API","title":"Agents.sample!","text":"sample!(model::ABM, n [, weight]; kwargs...)\n\nReplace the agents of the model with a random sample of the current agents with size n.\n\nOptionally, provide a weight: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the weight of the agent, the higher the probability that this agent will be chosen in the new sampling.\n\nKeywords\n\nreplace = true : whether sampling is performed with replacement, i.e. all agents can\n\nbe chosen more than once.\n\nrng = GLOBAL_RNG : a random number generator to perform the sampling with.\n\nExample usage in Wright-Fisher model of evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#Moving-agents","page":"API","title":"Moving agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"move_agent!\nwalk!","category":"page"},{"location":"api/#Agents.move_agent!","page":"API","title":"Agents.move_agent!","text":"move_agent!(agent [, pos], model::ABM) → agent\n\nMove agent to the given position, or to a random one if a position is not given. pos must have the appropriate position type depending on the space type.\n\nThe agent's position is updated to match pos after the move.\n\n\n\n\n\nmove_agent!(agent::A, model::ABM{<:ContinuousSpace,A}, dt::Real = 1.0)\n\nPropagate the agent forwards one step according to its velocity, after updating the agent's velocity (if configured, see ContinuousSpace). Also take care of periodic boundary conditions.\n\nFor this continuous space version of move_agent!, the \"evolution algorithm\" is a trivial Euler scheme with dt the step size, i.e. the agent position is updated as agent.pos += agent.vel * dt. If you want to move the agent to a specified position, do move_agent!(agent, pos, model).\n\n\n\n\n\nmove_agent!(agent, model::ABM{<:OpenStreetMapSpace}, distance::Real)\n\nMove an agent by distance in meters along its planned route.\n\n\n\n\n\nmove_agent!(agent::A, model::ABM{<:GridSpace,A,<:AStar})\n\nMoves the agent along the path to its target set by set_target!. If the agent does not have a precalculated path, or the path is empty, the agent does not move.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.walk!","page":"API","title":"Agents.walk!","text":"walk!(agent, direction::NTuple, model; ifempty = false)\n\nMove agent in the given direction respecting periodic boundary conditions. If periodic = false, agents will walk to, but not exceed the boundary value. Possible on both GridSpace and ContinuousSpaces.\n\nThe dimensionality of direction must be the same as the space. GridSpace asks for Int, and ContinuousSpace for Float64 vectors, describing the walk distance in each direction. direction = (2, -3) is an example of a valid direction on a GridSpace, which moves the agent to the right 2 positions and down 3 positions. Velocity is ignored for this opreation in ContinuousSpace.\n\nKeywords\n\nifempty will check that the target position is unnocupied and only move if that's true. Available only on GridSpace.\n\nExample usage in Battle Royale.\n\n\n\n\n\nwalk!(agent, rand, model)\n\nInvoke a random walk by providing the rand function in place of distance. For GridSpace, the walk will cover ±1 positions in all directions, ContinuousSpace will reside within [-1, 1].\n\n\n\n\n\n","category":"function"},{"location":"api/#Pathfinding","page":"API","title":"Pathfinding","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In addition to the direct movement functions listed above, GridSpace has the additional benefit of path planning.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AStar\nset_target!\nis_stationary\nwalkmap\nheightmap","category":"page"},{"location":"api/#Agents.AStar","page":"API","title":"Agents.AStar","text":"AStar(space::GridSpace; kwargs...)\n\nStores path data of agents, and relevant pathfinding grid data. The dimensions are taken to be those of the space.\n\nKeywords\n\nmoore_neighbors::Bool=true specifies if movement can be to Moore neighbors of a tile, or only Von Neumann neighbors.\nadmissibility::AbstractFloat=0.0 specifies how much a path can deviate from optimality, in favour of faster pathfinding. For an admissibility value of ε, a path with at most (1+ε) times the optimal path length will be calculated, exploring fewer nodes in the process. A value of 0 always finds the optimal path.\nwalkable::Array{Bool,D}=fill(true, size(space.s)) is used to specify (un)walkable positions of the space. Unwalkable positions are never part of any paths. By default, all positions are assumed to be walkable.\ncost_metric::Union{Type{M},M} where {M<:CostMetric}=DirectDistance specifies the metric used to approximate the distance between any two walkable points on the grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.set_target!","page":"API","title":"Agents.set_target!","text":"set_target!(agent::A, target::NTuple{D,Int}, model::ABM{<:GridSpace,A,<:AStar{D}})\n\nThis calculates and stores the shortest path to move the agent from its current position to target using find_path.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.is_stationary","page":"API","title":"Agents.is_stationary","text":"is_stationary(agent, model::ABM{<:GridSpace,A,<:AStar{D}})\n\nReturn true if agent has reached it's target destination, or no path has been set for it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.walkmap","page":"API","title":"Agents.walkmap","text":"walkmap(model::ABM{<:GridSpace{D},A,<:AStar{D})\n\nReturn the walkable map of the pathfinder\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.heightmap","page":"API","title":"Agents.heightmap","text":"heightmap(model::ABM{<:GridSpace{D},A,<:AStar{D})\n\nReturn the heightmap of the pathfinder if the HeightMap metric is in use, nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Metrics","page":"API","title":"Metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DirectDistance\nChebyshev\nHeightMap","category":"page"},{"location":"api/#Agents.DirectDistance","page":"API","title":"Agents.DirectDistance","text":"DirectDistance{D}(direction_costs::Vector{Int}=[floor(Int, 10.0*√x) for x in 1:D])\n\nThe default cost metric for AStar. Distance is approximated as the shortest path between the two points, where from any tile it is possible to step to any of its Moore neighbors. direction_costs is a Vector{Int} where direction_costs[i] represents the cost of going from a tile to the neighbording tile on the i dimensional diagonal. The default value is 10√i for the i dimensional diagonal, rounded down to the nearest integer.\n\nIf moore_neighbors=false in the AStar struct, then it is only possible to step to VonNeumann neighbors. In such a case, only direction_costs[1] is used.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Chebyshev","page":"API","title":"Agents.Chebyshev","text":"Chebyshev{D}()\n\nDistance between two tiles is approximated as the Chebyshev distance (maximum of absolute difference in coordinates) between them.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.HeightMap","page":"API","title":"Agents.HeightMap","text":"HeightMap(hmap::Array{Int,D})\nHeightMap(hmap::Array{Int,D}, ::Type{<:CostMetric})\n\nAn alternative CostMetric. This allows for a D dimensional heightmap to be provided as a D dimensional integer array, of the same size as the corresponding GridSpace{D}. This metric approximates the distance between two positions as the sum of the shortest distance between them and the absolute difference in heights between the two positions. The shortest distance is calculated using the underlying base_metric field, which defaults to DirectDistance\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Building a custom metric is straightforward, if the provided ones do not suit your purpose.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CostMetric","category":"page"},{"location":"api/#Agents.CostMetric","page":"API","title":"Agents.CostMetric","text":"CostMetric{D}\n\nAn abstract type representing a metric that measures the approximate cost of travelling between two points in a D dimensional GridSpace{D}. A struct with this as its base type is used as the cost_metric for AStar. To define a custom metric, define a struct with this as its base type and a corresponding method for delta_cost.\n\n\n\n\n\n","category":"type"},{"location":"api/#Advanced-Methods","page":"API","title":"Advanced Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Functions that are usually not needed to perform most path finding tasks, but may be helpful in certain situations.","category":"page"},{"location":"api/","page":"API","title":"API","text":"find_path\ndelta_cost","category":"page"},{"location":"api/#Agents.find_path","page":"API","title":"Agents.find_path","text":"find_path(pathfinder::AStar{D}, from::NTuple{D,Int}, to::NTuple{D,Int})\n\nUsing the specified AStar, calculates and returns the shortest path from from to to using the A* algorithm. Paths are returned as a MutableLinkedList of sequential grid positions. If a path does not exist between the given  positions, this returns an empty linked list. This function usually does not need to be called explicitly, instead the use the provided set_target! and move_agent! functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.delta_cost","page":"API","title":"Agents.delta_cost","text":"delta_cost(pathfinder::AStar{D}, from::NTuple{D, Int}, to::NTuple{D, Int})\n\nCalculates and returns an approximation for the cost of travelling from from to to. This calls the corresponding delta_cost(pathfinder, pathfinder.cost_metric, from, to) function. In the case of a custom metric, define a method for the latter function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Discrete-space-exclusives","page":"API","title":"Discrete space exclusives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"positions\nids_in_position\nagents_in_position\nfill_space!\nhas_empty_positions\nempty_positions\nrandom_empty\nadd_agent_single!\nmove_agent_single!\nisempty(::Integer, ::ABM)","category":"page"},{"location":"api/#Agents.positions","page":"API","title":"Agents.positions","text":"positions(model::ABM{<:DiscreteSpace}) → ns\n\nReturn an iterator over all positions of a model with a discrete space.\n\npositions(model::ABM{<:DiscreteSpace}, by::Symbol) → ns\n\nReturn all positions of a model with a discrete space, sorting them using the argument by which can be:\n\n:random - randomly sorted\n:population - positions are sorted depending on how many agents they accommodate. The more populated positions are first.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.ids_in_position","page":"API","title":"Agents.ids_in_position","text":"ids_in_position(position, model::ABM{<:DiscreteSpace})\nids_in_position(agent, model::ABM{<:DiscreteSpace})\n\nReturn the ids of agents in the position corresponding to position or position of agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.agents_in_position","page":"API","title":"Agents.agents_in_position","text":"agents_in_position(position, model::ABM{<:DiscreteSpace})\nagents_in_position(agent, model::ABM{<:DiscreteSpace})\n\nReturn the agents in the position corresponding to position or position of agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.fill_space!","page":"API","title":"Agents.fill_space!","text":"fill_space!([A ,] model::ABM{<:DiscreteSpace,A}, args...; kwargs...)\nfill_space!([A ,] model::ABM{<:DiscreteSpace,A}, f::Function; kwargs...)\n\nAdd one agent to each position in the model's space. Similarly with add_agent!, the function creates the necessary agents and the args...; kwargs... are propagated into agent creation. If instead of args... a function f is provided, then args = f(pos) is the result of applying f where pos is each position (tuple for grid, index for graph).\n\nAn optional first argument is an agent type to be created, and targets mixed agent models where the agent constructor cannot be deduced (since it is a union).\n\nExample usage in Daisyworld.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.has_empty_positions","page":"API","title":"Agents.has_empty_positions","text":"has_empty_positions(model::ABM{<:DiscreteSpace})\n\nReturn true if there are any positions in the model without agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.empty_positions","page":"API","title":"Agents.empty_positions","text":"empty_positions(model)\n\nReturn a list of positions that currently have no agents on them.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_empty","page":"API","title":"Agents.random_empty","text":"random_empty(model::ABM{<:DiscreteSpace})\n\nReturn a random position without any agents, or nothing if no such positions exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_single!","page":"API","title":"Agents.add_agent_single!","text":"add_agent_single!(agent, model::ABM{<:DiscreteSpace}) → agent\n\nAdd the agent to a random position in the space while respecting a maximum of one agent per position. This function does nothing if there aren't any empty positions.\n\n\n\n\n\nadd_agent_single!(model::ABM{<:DiscreteSpace}, properties...; kwargs...)\n\nSame as add_agent!(model, properties...) but ensures that it adds an agent into a position with no other agents (does nothing if no such position exists).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.move_agent_single!","page":"API","title":"Agents.move_agent_single!","text":"move_agent_single!(agent, model::ABM{<:DiscreteSpace}) → agentt\n\nMove agent to a random position while respecting a maximum of one agent per position. If there are no empty positions, the agent won't move.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.isempty-Tuple{Integer,AgentBasedModel}","page":"API","title":"Base.isempty","text":"isempty(position, model::ABM{<:DiscreteSpace})\n\nReturn true if there are no agents in position.\n\n\n\n\n\n","category":"method"},{"location":"api/#Continuous-space-exclusives","page":"API","title":"Continuous space exclusives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"interacting_pairs\nnearest_neighbor\nelastic_collision!","category":"page"},{"location":"api/#Agents.interacting_pairs","page":"API","title":"Agents.interacting_pairs","text":"interacting_pairs(model, r, method; scheduler = model.scheduler)\n\nReturn an iterator that yields unique pairs of agents (a1, a2) that are close neighbors to each other, within some interaction radius r.\n\nThis function is usefully combined with model_step!, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with a1 and with a2, which is unavoidable when using agent_step!).\n\nThe argument method provides three pairing scenarios\n\n:all: return every pair of agents that are within radius r of each other, not only the nearest ones.\n:nearest: agents are only paired with their true nearest neighbor (existing within radius r). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by distance, then by next id in scheduler) will be paired.\n:types: For mixed agent models only. Return every pair of agents within radius r (similar to :all), only capturing pairs of differing types. For example, a model of Union{Sheep,Wolf} will only return pairs of (Sheep, Wolf). In the case of multiple agent types, e.g. Union{Sheep, Wolf, Grass}, skipping pairings that involve Grass, can be achived by a scheduler that doesn't schedule Grass types, i.e.: scheduler(model) = (a.id for a in allagents(model) if !(a isa Grass)).\n\nExample usage in Bacterial Growth.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearest_neighbor","page":"API","title":"Agents.nearest_neighbor","text":"nearest_neighbor(agent, model::ABM{<:ContinuousSpace}, r) → nearest\n\nReturn the agent that has the closest distance to given agent. Return nothing if no agent is within distance r.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.elastic_collision!","page":"API","title":"Agents.elastic_collision!","text":"elastic_collision!(a, b, f = nothing)\n\nResolve a (hypothetical) elastic collision between the two agents a, b. They are assumed to be disks of equal size touching tangentially. Their velocities (field vel) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.\n\nIf f is a Symbol, then the agent property f, e.g. :mass, is taken as a mass to weight the two agents for the collision. By default no weighting happens.\n\nOne of the two agents can have infinite \"mass\", and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.\n\nExample usage in Continuous space social distancing for COVID-19.\n\n\n\n\n\n","category":"function"},{"location":"api/#OpenStreetMap-space-exclusives","page":"API","title":"OpenStreetMap space exclusives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"osm_latlon\nosm_intersection\nosm_road\nosm_random_road_position\nosm_plan_route\nosm_random_route!\nosm_road_length\nosm_is_stationary\nosm_map_coordinates","category":"page"},{"location":"api/#Agents.osm_latlon","page":"API","title":"Agents.osm_latlon","text":"osm_latlon(pos, model)\nosm_latlon(agent, model)\n\nReturn (latitude, longitude) of current road or intersection position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_intersection","page":"API","title":"Agents.osm_intersection","text":"osm_intersection(latlon::Tuple{Float64,Float64}, model::ABM{<:OpenStreetMapSpace})\n\nReturns the nearest intersection position to (latitude, longitude). Quicker, but less precise than osm_road.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_road","page":"API","title":"Agents.osm_road","text":"osm_road(latlon::Tuple{Float64,Float64}, model::ABM{<:OpenStreetMapSpace})\n\nReturns a location on a road nearest to (latitude, longitude). Slower, but more precise than osm_intersection.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_random_road_position","page":"API","title":"Agents.osm_random_road_position","text":"osm_random_road_position(model::ABM{OpenStreetMapSpace})\n\nSimilar to random_position, but rather than providing only intersections, this method returns a location somewhere on a road heading in a random direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_plan_route","page":"API","title":"Agents.osm_plan_route","text":"osm_plan_route(start, finish, model::ABM{<:OpenStreetMapSpace};\n               by = :shortest, return_trip = false, kwargs...)\n\nGenerate a list of intersections between start and finish points on the map. start and finish can either be intersections (Int) or positions (Tuple{Int,Int,Float64}).\n\nWhen either point is a position, the associated intersection index will be removed from the route to avoid double counting.\n\nRoute is planned via the shortest path by default (by = :shortest), but can also be planned by = :fastest. Road speeds are needed for this method which can be passed in via extra keyword arguments. Consult the OpenStreetMapX documentation for more details.\n\nIf return_trip = true, a route will be planned from start -> finish -> start.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_random_route!","page":"API","title":"Agents.osm_random_route!","text":"osm_random_route!(agent, model::ABM{<:OpenStreetMapSpace})\n\nSelects a random destination and plans a route from the agent's current position. Will overwrite any current route.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_road_length","page":"API","title":"Agents.osm_road_length","text":"osm_road_length(start::Int, finish::Int, model)\nosm_road_length(pos::Tuple{Int,Int,Float64}, model)\n\nReturn the road length (in meters) between two intersections given by intersection ids.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_is_stationary","page":"API","title":"Agents.osm_is_stationary","text":"osm_is_stationary(agent)\n\nReturn true if agent has no route left to follow and is therefore standing still.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.osm_map_coordinates","page":"API","title":"Agents.osm_map_coordinates","text":"osm_map_coordinates(agent, model::ABM{OpenStreetMapSpace})\n\nReturn a set of coordinates for an agent on the underlying map. Useful for plotting.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-space-exclusives","page":"API","title":"Graph space exclusives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"add_edge!\nadd_node!\nrem_node!","category":"page"},{"location":"api/#LightGraphs.SimpleGraphs.add_edge!","page":"API","title":"LightGraphs.SimpleGraphs.add_edge!","text":"add_edge!(model::ABM{<: GraphSpace}, n::Int, m::Int)\n\nAdd a new edge (relationship between two positions) to the graph. Returns a boolean, true if the operation was succesful.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_node!","page":"API","title":"Agents.add_node!","text":"add_node!(model::ABM{<: GraphSpace})\n\nAdd a new node (i.e. possible position) to the model's graph and return it. You can connect this new node with existing ones using add_edge!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.rem_node!","page":"API","title":"Agents.rem_node!","text":"rem_node!(model::ABM{<: GraphSpace}, n::Int)\n\nRemove node (i.e. position) n from the model's graph. All agents in that node are killed.\n\nWarning: LightGraphs.jl (and thus Agents.jl) swaps the index of the last node with that of the one to be removed, while every other node remains as is. This means that when doing rem_node!(n, model) the last node becomes the n-th node while the previous n-th node (and all its edges and agents) are deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Local-area","page":"API","title":"Local area","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"nearby_ids\nnearby_agents\nnearby_positions\nedistance","category":"page"},{"location":"api/#Agents.nearby_ids","page":"API","title":"Agents.nearby_ids","text":"nearby_ids(position, model::ABM, r; kwargs...) → ids\n\nReturn an iterable of the ids of the agents within \"radius\" r of the given position (which must match type with the spatial structure of the model).\n\nWhat the \"radius\" means depends on the space type:\n\nGraphSpace: the degree of neighbors in the graph (thus r is always an integer). For example, for r=2 include first and second degree neighbors.\nGridSpace, ContinuousSpace: Either Chebyshev (also called Moore) or Euclidean distance, in the space of cartesian indices.\nGridSpace can also take a tuple argument, e.g. r = (5, 2) for a 2D space, which\n\nextends 5 positions in the x direction and 2 in the y. Only possible with Chebyshev spaces.\n\nOpenStreetMapSpace: r is equivalent with distance (in meters) neeeded to be travelled according to existing roads in order to reach given position.\n\nKeywords\n\nKeyword arguments are space-specific. For GraphSpace the keyword neighbor_type=:default can be used to select differing neighbors depending on the underlying graph directionality type.\n\n:default returns neighbors of a vertex (position). If graph is directed, this is equivalent to :out. For undirected graphs, all options are equivalent to :out.\n:all returns both :in and :out neighbors.\n:in returns incoming vertex neighbors.\n:out returns outgoing vertex neighbors.\n\nFor ContinuousSpace, the keyword exact=false controls whether the found neighbors are exactly accurate or approximate (with approximate always being a strict over-estimation), see ContinuousSpace.\n\n\n\n\n\nnearby_ids(agent::AbstractAgent, model::ABM, r=1)\n\nSame as nearby_ids(agent.pos, model, r) but the iterable excludes the given agent's id.\n\n\n\n\n\nnearby_ids(pos, model::ABM{<:GridSpace}, r::Vector{Tuple{Int,UnitRange{Int}}})\n\nReturn an iterable of ids over specified dimensions of space with fine grained control of distances from pos using each value of r via the (dimension, range) pattern.\n\nNote: Only available for use with non-periodic chebyshev grids.\n\nExample, with a GridSpace((100, 100, 10)): r = [(1, -1:1), (3, 1:2)] searches dimension 1 one step either side of the current position (as well as the current position) and the third dimension searches two positions above current.\n\nFor a complete tutorial on how to use this method, see Battle Royale.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearby_agents","page":"API","title":"Agents.nearby_agents","text":"nearby_agents(agent, model::ABM, args...; kwargs...) -> agent\n\nReturn an iterable of the agents near the position of the given agent.\n\nThe value of the argument r and possible keywords operate identically to nearby_ids.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearby_positions","page":"API","title":"Agents.nearby_positions","text":"nearby_positions(position, model::ABM, r=1; kwargs...) → positions\n\nReturn an iterable of all positions within \"radius\" r of the given position (which excludes given position). The position must match type with the spatial structure of the model.\n\nThe value of r and possible keywords operate identically to nearby_ids.\n\nThis function only makes sense for discrete spaces with a finite amount of positions.\n\nnearby_positions(position, model::ABM{<:OpenStreetMapSpace}; kwargs...) → positions\n\nFor OpenStreetMapSpace this means \"nearby intersections\" and operates directly on the underlying graph of the OSM, providing the intersection nodes nearest to the given position.\n\n\n\n\n\nnearby_positions(agent::AbstractAgent, model::ABM, r=1)\n\nSame as nearby_positions(agent.pos, model, r).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.edistance","page":"API","title":"Agents.edistance","text":"edistance(a, b, model::ABM)\n\nReturn the euclidean distance between a and b (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently GridSpace and ContinuousSpace.\n\nExample usage in the Flock model.\n\n\n\n\n\n","category":"function"},{"location":"api/#A-note-on-iteration","page":"API","title":"A note on iteration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Most iteration in Agents.jl is dynamic and lazy, when possible, for performance reasons.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Dynamic means that when iterating over the result of e.g. the ids_in_position function, the iterator will be affected by actions that would alter its contents. Specifically, imagine the scenario","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Agents\nmutable struct Agent <: AbstractAgent\n    id::Int\n    pos::NTuple{4, Int}\nend\n\nmodel = ABM(Agent, GridSpace((5, 5, 5, 5)))\nadd_agent!((1, 1, 1, 1), model)\nadd_agent!((1, 1, 1, 1), model)\nadd_agent!((2, 1, 1, 1), model)\nfor id in ids_in_position((1, 1, 1, 1), model)\n    kill_agent!(id, model)\nend\ncollect(allids(model))","category":"page"},{"location":"api/","page":"API","title":"API","text":"You will notice that only 1 agent got killed. This is simply because the final state of the iteration of ids_in_position was reached unnaturally, because the length of its output was reduced by 1 during iteration. To avoid problems like these, you need to collect the iterator to have a non dynamic version.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Lazy means that when possible the outputs of the iteration are not collected and instead are generated on the fly. A good example to illustrate this is nearby_ids, where doing something like","category":"page"},{"location":"api/","page":"API","title":"API","text":"a = random_agent(model)\nsort!(nearby_ids(random_agent(model), model))","category":"page"},{"location":"api/","page":"API","title":"API","text":"leads to error, since you cannot sort! the returned iterator. This can be easily solved by adding a collect in between:","category":"page"},{"location":"api/","page":"API","title":"API","text":"a = random_agent(model)\nsort!(collect(nearby_agents(a, model)))","category":"page"},{"location":"api/#Higher-order-interactions","page":"API","title":"Higher-order interactions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"There may be times when pair-wise, triplet-wise or higher interactions need to be accounted for across most or all of the model's agent population. The following methods provide an interface for such calculation.","category":"page"},{"location":"api/","page":"API","title":"API","text":"iter_agent_groups\nmap_agent_groups\nindex_mapped_groups","category":"page"},{"location":"api/#Agents.iter_agent_groups","page":"API","title":"Agents.iter_agent_groups","text":"iter_agent_groups(order::Int, model::ABM; scheduler = by_id)\n\nReturn an iterator over all agents of the model, grouped by order. When order = 2, the iterator returns agent pairs, e.g (agent1, agent2) and when order = 3: agent triples, e.g. (agent1, agent7, agent8). order must be larger than 1 but has no upper bound.\n\nIndex order is provided by the by_id scheduler by default, but can be altered with the scheduler keyword.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.map_agent_groups","page":"API","title":"Agents.map_agent_groups","text":"map_agent_groups(order::Int, f::Function, model::ABM; kwargs...)\nmap_agent_groups(order::Int, f::Function, model::ABM, filter::Function; kwargs...)\n\nApplies function f to all grouped agents of an iter_agent_groups iterator. kwargs are passed to the iterator method. f must take the form f(NTuple{O,AgentType}), where the dimension O is equal to order.\n\nOptionally, a filter function that accepts an iterable and returns a Bool can be applied to remove unwanted matches from the results. Note: This option cannot keep matrix order, so should be used in conjuction with index_mapped_groups to associate agent ids with the resultant data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.index_mapped_groups","page":"API","title":"Agents.index_mapped_groups","text":"index_mapped_groups(order::Int, model::ABM; scheduler = by_id)\nindex_mapped_groups(order::Int, model::ABM, filter::Function; scheduler = by_id)\n\nReturn an iterable of agent ids in the model, meeting the filter criterea if used.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parameter-scanning","page":"API","title":"Parameter scanning","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"paramscan","category":"page"},{"location":"api/#Agents.paramscan","page":"API","title":"Agents.paramscan","text":"paramscan(parameters, initialize; kwargs...) → adf, mdf\n\nPerform a parameter scan of a ABM simulation output by collecting data from all parameter combinations into dataframes (one for agent data, one for model data). The dataframes columns are both the collected data (as in run!) but also the input parameter values used.\n\nparameters is a dictionary with key type Symbol which contains various parameters that will be scanned over (as well as other parameters that remain constant). This function uses DrWatson's dict_list convention. This means that every entry of parameters that is a Vector contains many parameters and thus is scanned. All other entries of parameters that are not Vectors are not expanded in the scan.\n\nThe second argument initialize is a function that creates an ABM and returns it. It should accept keyword arguments which are the keys of the parameters dictionary. Since the user decides how to use input arguments to make an ABM, parameters can be used to affect model properties, space type and creation as well as agent properties, see the example below.\n\nKeywords\n\nThe following keywords modify the paramscan function:\n\ninclude_constants::Bool=false determines whether constant parameters should be included in the output DataFrame.\nprogress::Bool = true whether to show the progress of simulations.\n\nThe following keywords are propagated into run!:\n\nagent_step!, model_step!, n, when, step0, parallel, replicates, adata, mdata\n\nagent_step!, model_step!, n and at least one of adata, mdata are mandatory.\n\nExample\n\nA runnable example that uses paramscan is shown in Schelling's segregation model. There we define\n\nfunction initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3)\n    space = GridSpace(griddims, moore = true)\n    properties = Dict(:min_to_be_happy => min_to_be_happy)\n    model = ABM(SchellingAgent, space;\n                properties = properties, scheduler = random_activation)\n    for n in 1:numagents\n        agent = SchellingAgent(n, (1, 1), false, n < numagents / 2 ? 1 : 2)\n        add_agent_single!(agent, model)\n    end\n    return model\nend\n\nand do a parameter scan by doing:\n\nhappyperc(moods) = count(x -> x == true, moods) / length(moods)\nadata = [(:mood, happyperc)]\n\nparameters = Dict(\n    :min_to_be_happy => collect(2:5), # expanded\n    :numagents => [200, 300],         # expanded\n    :griddims => (20, 20),            # not Vector = not expanded\n)\n\ndata, _ = paramscan(parameters, initialize; adata = adata, n = 3, agent_step! = agent_step!)\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-collection","page":"API","title":"Data collection","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The central simulation function is run!, which is mentioned in our Tutorial. But there are other functions that are related to simulations listed here. Specifically, these functions aid in making custom data collection loops, instead of using the run! function.","category":"page"},{"location":"api/","page":"API","title":"API","text":"For example, the core loop of run! is just","category":"page"},{"location":"api/","page":"API","title":"API","text":"df_agent = init_agent_dataframe(model, adata)\ndf_model = init_model_dataframe(model, mdata)\n\ns = 0\nwhile until(s, n, model)\n  if should_we_collect(s, model, when)\n      collect_agent_data!(df_agent, model, adata, s)\n  end\n  if should_we_collect(s, model, when_model)\n      collect_model_data!(df_model, model, mdata, s)\n  end\n  step!(model, agent_step!, model_step!, 1)\n  s += 1\nend\nreturn df_agent, df_model","category":"page"},{"location":"api/","page":"API","title":"API","text":"(here until and should_we_collect are internal functions)","category":"page"},{"location":"api/","page":"API","title":"API","text":"run! uses the following functions:","category":"page"},{"location":"api/","page":"API","title":"API","text":"init_agent_dataframe\ncollect_agent_data!\ninit_model_dataframe\ncollect_model_data!\naggname","category":"page"},{"location":"api/#Agents.init_agent_dataframe","page":"API","title":"Agents.init_agent_dataframe","text":"init_agent_dataframe(model, adata) → agent_df\n\nInitialize a dataframe to add data later with collect_agent_data!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.collect_agent_data!","page":"API","title":"Agents.collect_agent_data!","text":"collect_agent_data!(df, model, properties, step = 0; obtainer = identity)\n\nCollect and add agent data into df (see run! for the dispatch rules of properties and obtainer). step is given because the step number information is not known.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.init_model_dataframe","page":"API","title":"Agents.init_model_dataframe","text":"init_model_dataframe(model, mdata) → model_df\n\nInitialize a dataframe to add data later with collect_model_data!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.collect_model_data!","page":"API","title":"Agents.collect_model_data!","text":"collect_model_data!(df, model, properties, step = 0, obtainer = identity)\n\nSame as collect_agent_data! but for model data instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.aggname","page":"API","title":"Agents.aggname","text":"aggname(k) → name\naggname(k, agg) → name\naggname(k, agg, condition) → name\n\nReturn the name of the column of the i-th collected data where k = adata[i] (or mdata[i]). aggname also accepts tuples with aggregate and conditional values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Schedulers","page":"API","title":"Schedulers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The schedulers of Agents.jl have a very simple interface. All schedulers are functions, that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a \"true\" iterator (non-allocated) or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an AgentBasedModel. You can also use the function schedule(model) to obtain the scheduled ID list, if you prefer to write your own step!-like loop.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Notice that schedulers can be given directly to model creation, and thus become the \"default\" scheduler a model uses, but they can just as easily be incorporated in a model_step! function as shown in Advanced stepping.","category":"page"},{"location":"api/#Predefined-schedulers","page":"API","title":"Predefined schedulers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Some useful schedulers are available below as part of the Agents.jl public API:","category":"page"},{"location":"api/","page":"API","title":"API","text":"fastest\nby_id\nrandom_activation\npartial_activation\nproperty_activation\nby_type","category":"page"},{"location":"api/#Agents.fastest","page":"API","title":"Agents.fastest","text":"fastest\n\nActivate all agents once per step in the order dictated by the agent's container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.by_id","page":"API","title":"Agents.by_id","text":"by_id\n\nActivate agents at each step according to their id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_activation","page":"API","title":"Agents.random_activation","text":"random_activation\n\nActivate agents once per step in a random order. Different random ordering is used at each different step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.partial_activation","page":"API","title":"Agents.partial_activation","text":"partial_activation(p)\n\nAt each step, activate only p percentage of randomly chosen agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.property_activation","page":"API","title":"Agents.property_activation","text":"property_activation(property)\n\nAt each step, activate the agents in an order dictated by their property, with agents with greater property acting first. property is a Symbol, which just dictates which field the agents to compare.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.by_type","page":"API","title":"Agents.by_type","text":"by_type(shuffle_types::Bool, shuffle_agents::Bool)\n\nUseful only for mixed agent models using Union types.\n\nSetting shuffle_types = true groups by agent type, but randomizes the type order.\n\nOtherwise returns agents grouped in order of appearance in the Union.\n\nshuffle_agents = true randomizes the order of agents within each group, false returns\n\nthe default order of the container (equivalent to fastest).\n\n\n\n\n\nby_type((C, B, A), shuffle_agents::Bool)\n\nActivate agents by type in specified order (since Unions are not order preserving). shuffle_agents = true randomizes the order of agents within each group.\n\n\n\n\n\n","category":"function"},{"location":"api/#Advanced-scheduling","page":"API","title":"Advanced scheduling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"You can use Function-like-objects to make your scheduling possible of arbitrary events. For example, imagine that after the n-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define","category":"page"},{"location":"api/","page":"API","title":"API","text":"mutable struct MyScheduler\n    n::Int # step number\n    w::Float64\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"and then define a calling method for it like so","category":"page"},{"location":"api/","page":"API","title":"API","text":"function (ms::MyScheduler)(model::ABM)\n    ms.n += 1 # increment internal counter by 1 each time its called\n              # be careful to use a *new* instance of this scheduler when plotting!\n    if ms.n < 10\n        return allids(model) # order doesn't matter in this case\n    else\n        ids = collect(allids(model))\n        # filter all ids whose agents have `w` less than some amount\n        filter!(id -> model[id].w < ms.w, ids)\n        return ids\n    end\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"and pass it to e.g. step! by initializing it","category":"page"},{"location":"api/","page":"API","title":"API","text":"ms = MyScheduler(100, 0.5)\nstep!(model, agentstep, modelstep, 100; scheduler = ms)","category":"page"},{"location":"interact/#Plotting-and-interactive-application","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"","category":"section"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"Plotting and interaction functionality comes from InteractiveDynamics, another package of JuliaDynamics, which uses Makie.jl.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"Plotting, and the interactive application of Agents.jl, are model-agnostic and simple to use. Defining simple functions that map agents to colors, and shapes, is the only thing you need to do. If you have already defined an ABM and functions for stepping the model, you typically need to write only an extra couple of lines of code to get your visualizations going.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"You need to install both InteractiveDynamics, as well as a plotting backend (we recommend GLMakie) to use the following functions.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"The version of InteractiveDynamics used in the docs is:","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"using Pkg\nPkg.status(\"InteractiveDynamics\")","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"Some parts of Agents.jl cannot be plotted yet in Makie.jl, and therefore alternatives are provided. However in the near future we hope to have moved everything to plotting with Makie.jl and not necessitate usage of Plots.jl or other libraries.","category":"page"},{"location":"interact/#Plotting","page":"Plotting and interactive application","title":"Plotting","text":"","category":"section"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"The following functions allow you to plot an ABM, animate it via play/pause buttons, or directly export the time evolution into a video. At the moment these functions support 2D continuous and discrete space.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"InteractiveDynamics.abm_plot\nInteractiveDynamics.abm_play\nInteractiveDynamics.abm_video","category":"page"},{"location":"interact/#InteractiveDynamics.abm_plot","page":"Plotting and interactive application","title":"InteractiveDynamics.abm_plot","text":"abm_plot(model::ABM; kwargs...) → fig, abmstepper\n\nPlot an agent based model by plotting each individual agent as a marker and using the agent's position field as its location on the plot. Requires Agents.\n\nReturn the overarching fig object, as well as a struct abmstepper that can be used to interactively animate the evolution of the ABM and combine it with other subplots. The figure is not displayed by default, you need to either return fig as a last statement in your functions or simply call display(fig). To progress the ABM plot n steps simply do:\n\nAgents.step!(abmstepper, model, agent_step!, model_step!, n)\n\nYou can still call this function with n=0 to update the plot for a new model, without doing any stepping. From fig you can obtain the plotted axis (to e.g. turn off ticks, etc.) using ax = content(fig[1, 1]). See Sugarscape for an example of using abmstepper to make an animation of evolving the ABM and a heatmap in parallel with only a few lines of code.\n\nKeywords\n\nac, as, am: These three keywords decided the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a function, which takes as an input a single argument and ouputs the corresponding value. For example:\n# ac = \"#338c54\"\nac(a) = a.status == :S ? \"#2b2b33\" : a.status == :I ? \"#bf2642\" : \"#338c54\"\n# as = 10\nas(a) = 10*randn() + 1\n# as = :diamond\nas(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect\nNotice that am can be/return a Polygon instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent's position when creating the polygon. In this case, the keyword as is meaningless, as each polygon has its own size. Use the functions scale, rotate2D to transform this polygon.\nscheduler = model.scheduler: decides the plotting order of agents (which matters only if there is overlap).\noffset = nothing: If not nothing, it must be a function taking as an input an agent and outputting an offset position vector to be added to the agent's position (which matters only if there is overlap).\nequalaspect = true: Whether the plot should be of equal aspect ratio.\nscatterkwargs = (): Additional keyword arguments propagated to the scatter plot. If am is/returns Polygons, then these arguments are propagated to a poly plot.\nresolution = (600, 600): Resolution of the fig.\n\n\n\n\n\n","category":"function"},{"location":"interact/#InteractiveDynamics.abm_play","page":"Plotting and interactive application","title":"InteractiveDynamics.abm_play","text":"abm_play(model, agent_step!, model_step!; kwargs...) → fig, abmstepper\n\nLaunch an interactive application that plots an agent based model and can animate its evolution in real time. Requires Agents.\n\nThe agents are plotted exactly like in abm_plot, while the two functions agent_step!, model_step! decide how the model will evolve, as in the standard approach of Agents.jl and its step! function.\n\nThe application has two buttons: \"run\" and \"reset\" which starts/stops the time evolution and resets the model to its original configuration. Two sliders control the animation speed: \"spu\" decides how many model steps should be done before the plot is updated, and \"sleep\" the sleep() time between updates.\n\nKeywords\n\nac, am, as, scheduler, offset, equalaspect, scatterkwargs: propagated to abm_plot.\nspu = 1:100: The values of the \"spu\" slider.\n\n\n\n\n\n","category":"function"},{"location":"interact/#InteractiveDynamics.abm_video","page":"Plotting and interactive application","title":"InteractiveDynamics.abm_video","text":"abm_video(file, model, agent_step! [, model_step!]; kwargs...)\n\nThis function exports the animated time evolution of an agent based model into a video saved at given path file, by recording the behavior of abm_play (without sliders). The plotting is identical as in abm_plot.\n\nKeywords\n\nac, am, as, scheduler, offset, equalaspect, scatterkwargs: propagated to abm_plot.\nspf = 1: Steps-per-frame, i.e. how many times to step the model before recording a new frame.\nframerate = 30: The frame rate of the exported video.\nframes = 300: How many frames to record in total, including the starting frame.\nresolution = (600, 600): Resolution of the fig.\naxiskwargs = NamedTuple(): Keyword arguments given to the main axis creation for e.g. setting xticksvisible = false.\n\n\n\n\n\n","category":"function"},{"location":"interact/#Interactive-application","page":"Plotting and interactive application","title":"Interactive application","text":"","category":"section"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"InteractiveDynamics.abm_data_exploration","category":"page"},{"location":"interact/#InteractiveDynamics.abm_data_exploration","page":"Plotting and interactive application","title":"InteractiveDynamics.abm_data_exploration","text":"abm_data_exploration(model::ABM, agent_step!, model_step!, params=Dict(); kwargs...)\n\nOpen an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires Agents.\n\nThe application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in abm_play, and the arguments model, agent_step!, model_step! are propagated there as-is.\n\nCalling abm_data_exploration returns: figure, agent_df, model_df. So you can save the figure, but you can also access the collected data (if any).\n\nInteraction\n\nBesides the basic time evolution interaction of abm_play, additional functionality here allows changing model parameters in real time, based on the provided fourth argument params. This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of params is a pair of Symbol to an AbstractVector, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only updated into the actual model when pressing the \"update\" button.\n\nThe \"reset\" button resets the model to its original agent and space state but it updates it to the currently selected parameter values. A red vertical line is displayed in the data plots when resetting, for visual guidance.\n\nKeywords\n\nac, am, as, scheduler, offset, equalaspect, scatterkwargs: propagated to abm_plot.\nadata, mdata: Same as the keyword arguments of Agents.run!, and decide which data of the model/agents will be collected and plotted below the interactive plot. Notice that data collection can only occur on plotted steps (and thus steps not plotted due to \"spu\" are also not data-collected).\nalabels, mlabels: If data are collected from agents or the model with adata, mdata, the corresponding plots have a y-label named after the collected data. Instead, you can give alabels, mlabels (vectors of strings with exactly same length as adata, mdata), and these labels will be used instead.\nwhen = true: When to perform data collection, as in Agents.run!.\nspu = 1:100: Values that the \"spu\" slider will obtain.\n\n\n\n\n\n","category":"function"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"Here is an example application made with InteractiveDynamics.abm_data_exploration.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"the application is made with the following script:","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"using InteractiveDynamics, Agents, Random, Statistics\nimport GLMakie\n\nRandom.seed!(165) # hide\nmodel, agent_step!, model_step! = Models.daisyworld(;\n    solar_luminosity = 1.0, solar_change = 0.0, scenario = :change\n)\nDaisy, Land = Agents.Models.Daisy, Agents.Models.Land\n\n# Parameter define agent color and shape:\nusing GLMakie.AbstractPlotting: to_color\ndaisycolor(a::Daisy) = RGBAf0(to_color(a.breed))\nlandcolor = cgrad(:thermal)\ndaisycolor(a::Land) = to_color(landcolor[(a.temperature+50)/150])\n\ndaisyshape(a::Daisy) = '♣'\ndaisysize(a::Daisy) = 15\ndaisyshape(a::Land) = :rect\ndaisysize(a::Land) = 20\nlandfirst = by_type((Land, Daisy), false) # scheduler\n\n# Parameter exploration and data collection:\nparams = Dict(\n    :solar_change => -0.1:0.01:0.1,\n    :surface_albedo => 0:0.01:1,\n)\n\nblack(a) = a.breed == :black\nwhite(a) = a.breed == :white\ndaisies(a) = a isa Daisy\nland(a) = a isa Land\nadata = [(black, count, daisies), (white, count, daisies), (:temperature, mean, land)]\nmdata = [:solar_luminosity]\n\nalabels = [\"black\", \"white\", \"T\"]\nmlabels = [\"L\"]\n\nmodel, agent_step!, model_step! = Models.daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)\n\nfig, adf, mdf = abm_data_exploration(\n    model, agent_step!, model_step!, params;\n    ac = daisycolor, am = daisyshape, as = daisysize,\n    mdata, adata, alabels, mlabels,\n    scheduler = landfirst # crucial to change model scheduler!\n)","category":"page"},{"location":"interact/#Graph-plotting","page":"Plotting and interactive application","title":"Graph plotting","text":"","category":"section"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"To plot agents existing of a GraphSpace we can't use InteractiveDynamics because Makie.jl does not support plotting on graphs (yet). We provide the following function in this case, which comes into scope when using Plots. See also the SIR model for the spread of COVID-19 example for an application.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"abm_plot_on_graph","category":"page"},{"location":"interact/#Open-Street-Map-plotting","page":"Plotting and interactive application","title":"Open Street Map plotting","text":"","category":"section"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"Plotting an open street map is also not possible with Makie.jl at the moment, but there is a Julia package that does this kind of plotting, OpenStreetMapXPlots.jl. Its usage is demonstrated in the Zombie Outbreak example page.","category":"page"},{"location":"interact/#Plots.jl-Recipes","page":"Plotting and interactive application","title":"Plots.jl Recipes","text":"","category":"section"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"Whilst the primary method for plotting agents models is through InteractiveDynamics, the following Plots recipes can also be used if you prefer the Plots.jl ecosystem.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"Notice that these methods will emit a warning. Pass warn = false to suppress it.","category":"page"},{"location":"interact/","page":"Plotting and interactive application","title":"Plotting and interactive application","text":"plotabm\nplotabm!","category":"page"},{"location":"comparison/#ABM-Framework-Comparison","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"","category":"section"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Many agent-based modeling frameworks have been constructed to ease the process of building and analyzing ABMs (see here for a review). Notable examples are NetLogo, Repast, MASON, and Mesa.","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"In this page we compare Agents.jl with Mesa, Netlogo and Mason, to assess where Agents.jl excels and also may need some future improvement. We used the following models for the comparison:","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Model of predator prey dynamics (Wolf Sheep Grass), a GridSpace model, which requires agents to be added, removed and moved; as well as identify properties of neighbouring positions.\nThe Flock model (Flocking), a ContinuousSpace model, chosen over other models to include a MASON benchmark. Agents must move in accordance with social rules over the space.\nThe Forest fire model (Forest Fire), provides comparisons for cellular automata type ABMs (i.e. when agents do not move). NOTE: The Agents.jl implementation of this model has been changed in v4.0 to be directly comparable to Mesa and NetLogo. As a consequence it no longer follows the original rule-set.\nSchelling's-segregation-model (Schelling), an additional GridSpace model to compare with MASON. Simpler rules than Wolf Sheep Grass.","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"The results are characterised in two ways: how long it took each model to perform the same scenario (initial conditions, grid size, run length etc. are the same across all frameworks), and how many lines of code (LOC) it took to describe each model and its dynamics. We use this result as a metric to represent the complexity of learning and working with a framework.","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Time taken is presented in normalised units, measured against the runtime of Agents.jl. In other words: the results do not depend on any computers specific hardware. If one wishes to repeat the results personally by using the scripts in benchmark/compare/, they will compute the same results. For details on the parameters used for each comparison, see the benchmark/compare/benchmark.jl file in our GitHub repository.","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"For LOC, we use the following convention: code is formatted using standard practices & linting for the associated language. Documentation strings and in-line comments (residing on lines of their own) are discarded, as well as any benchmark infrastructure. NetLogo is assigned two values since its files have a code base section and an encoding of the GUI. Since many parameters live in the GUI, we must take this into account. Thus 375 (785) in a NetLogo count means 375 lines in the code section, 785 lines total in the file.","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Model/Framework Agents Mesa Netlogo MASON\nWolf Sheep Grass 1 6.9x 2.1x NA\n(LOC) 139 238 137 (871) .\nFlocking 1 29.7x 10.3xᕯ 2.1x\n(LOC) 66 120 82 (689) 369\nForest Fire 1 22.5x 4.1x NA\n(LOC) 27 42 43 (545) .\nSchelling 1 29.6x 8.0x 14.3x\n(LOC) 34 57 68 (732) 248","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"ᕯ Netlogo has a different implementation to the other three frameworks here. It cheats a little by only choosing one nearest neighbor in some cases rather than considering all neighbors within vision. So a true comparison would ultimately see a slower result.","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"The results clearly speak for themselves. Across all four models, Agents.jl's performance is exceptional whilst using the least amount of code. This removes many frustrating barriers-to-entry for new users, and streamlines the development process for established ones.","category":"page"},{"location":"comparison/#Table-based-comparison","page":"ABM Framework Comparison","title":"Table-based comparison","text":"","category":"section"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"In an our paper discussing Agents.jl, we compiled a comparison over a large list of features and metrics from the four frameworks discussed above. They are shown below in a table-based format:","category":"page"},{"location":"comparison/","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"(Image: Table 1) (Image: Table 1 continued)","category":"page"},{"location":"examples/#Overview-of-Examples","page":"Overview","title":"Overview of Examples","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Our ever growing list of examples are designed to showcase what is possible with Agents.jl. Here, we outline a number of topics that new and advanced users alike can quickly reference to find exactly what they're looking for.","category":"page"},{"location":"examples/#I've-never-used-an-ABM-before-where-should-I-start?","page":"Overview","title":"I've never used an ABM before where should I start?","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"The simplest, and most thoroughly discussed example we have is Schelling's segregation model. Here, you will learn how to create an agent, define its actions, collect data from an experiment, plot results and even how to set up multiple experiments in parallel.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Opinion spread is another all-round showcase of these topics, with some interesting, yet more complicated dynamics.","category":"page"},{"location":"examples/#Concepts","page":"Overview","title":"Concepts","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"There are many things to learn in the ABM space. Here are some of the more common ones Agents.jl covers.","category":"page"},{"location":"examples/#Spaces","page":"Overview","title":"Spaces","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Choosing what kind of space your agents occupy is a fundamental aspect of model creation. Agents.jl provides a number of solutions, and the ability to create your own.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Maybe you don't need a space? The Wright-Fisher model of evolution is a good example to take a look at first to see if you can solve your problem without one.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Making a discrete grid is perhaps the easiest way to conceptualise space in a model. Sugarscape is one of our more complex examples, but gives you a good overview of what is possible on a grid. If you're looking for something simpler, then the Forest fire model would be a good start.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"A more complex, but far more powerful space type is something we call ContinuousSpace. In this space, agents generally move with a given velocity and interact in a far smoother manner than grid based models. The Flock model is perhaps the most famous example of bottom-up emergent phenomena. Something quite topical at present is our Continuous space social distancing for COVID-19 example. Finally, an excellent example of what can be done in a continuous space: Bacterial Growth.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Perhaps geographical space is not so important for your model, but connections between agents in some other manner is. A GraphSpace may be the answer. SIR model for the spread of COVID-19 showcases how viral spread may occur in populations.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Using graphs in conjunction with grid spaces is also possible, we discuss this in one of our integration pages: Social networks with LightGraphs.jl.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Finally, Battle Royale is an advanced example which leverages a 3-dimensional grid space, but only uses 2 of those dimensions for space. The third represents an agent category. Here, we can leverage Agents.jl's sophisticated neighbor searches to find closely related agents not just in space, but also in property.","category":"page"},{"location":"examples/#Synchronous-agent-updates","page":"Overview","title":"Synchronous agent updates","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Most of the time, using the agent_step! loop then the model_step! is sufficient to evolve a model. What if there's a more complicated set of dynamics you need to employ? Take a look at the HK (Hegselmann and Krause) opinion dynamics model: it shows us how to make a second agent loop within model_step! to synchronise changes across all agents after agent_step! dynamics have completed.","category":"page"},{"location":"examples/#Agent-sampling","page":"Overview","title":"Agent sampling","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"The Wright-Fisher model of evolution shows us how we can sample a population of agents based on certain model properties. This is quite helpful in genetic and biology studies where agents are cell analogues.","category":"page"},{"location":"examples/#Cellular-Automata","page":"Overview","title":"Cellular Automata","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"A subset of ABMs, these models have individual agents with a set of behaviors, interacting with neighboring cells and the world around them, but never moving. Two famous examples of this model type are Conway's game of life and Daisyworld.","category":"page"},{"location":"examples/#Mixed-Models","page":"Overview","title":"Mixed Models","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"In the real world, groups of people interact differently with people they know vs people they don't know. In ABM worlds, that's no different. Model of predator-prey dynamics (or more colloquially: Wolf-Sheep) implements interactions between a pack of Wolves, a heard of Sheep and meadows of Grass. Daisyworld is an example of how a model property (in this case temperature) can be elevated to an agent type.","category":"page"},{"location":"examples/#Advanced-Topics","page":"Overview","title":"Advanced Topics","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"One major difference between Agents.jl and other ABM frameworks is how integrated it is to the greater ecosystem of the Julia language and by extension the tools one can apply in their models. Take a look at some of the more advanced walkthroughs in the Ecosystem Integration page of this documentation for details.","category":"page"},{"location":"models/#Predefined-Models","page":"Predefined Models","title":"Predefined Models","text":"","category":"section"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"Predefined agent based models exist in the Models submodule in the form of functions that return model, agent_step!, model_step! when called.","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"They are accessed like:","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"using Agents\nmodel, agent_step!, model_step! = Models.flocking(; kwargs...)","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"The Examples section of the docs outline how to use and interact with each model.","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"So far, the predefined models that exist in the Models sub-module are:","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"Modules = [Models]\nOrder   = [:function]","category":"page"},{"location":"models/#Agents.Models.battle-Tuple{}","page":"Predefined Models","title":"Agents.Models.battle","text":"battle(; fighters = 50)\n\nSame as in Battle Royale.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.daisyworld-Tuple{}","page":"Predefined Models","title":"Agents.Models.daisyworld","text":"daisyworld(;\n    griddims = (30, 30),\n    max_age = 25,\n    init_white = 0.2,\n    init_black = 0.2,\n    albedo_white = 0.75,\n    albedo_black = 0.25,\n    surface_albedo = 0.4,\n    solar_change = 0.005,\n    solar_luminosity = 1.0,\n    scenario = :default,\n    seed = 165\n)\n\nSame as in Daisyworld.\n\nTo access the Daisy and Land types, simply call\n\nusing Agents.Models: Daisy, Land\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.flocking-Tuple{}","page":"Predefined Models","title":"Agents.Models.flocking","text":"flocking(;\n    n_birds = 100,\n    speed = 1.0,\n    cohere_factor = 0.25,\n    separation = 4.0,\n    separate_factor = 0.25,\n    match_factor = 0.01,\n    visual_distance = 5.0,\n    extent = (100, 100),\n    spacing = visual_distance / 1.5\n)\n\nSame as in Flock model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.forest_fire-Tuple{}","page":"Predefined Models","title":"Agents.Models.forest_fire","text":"forest_fire(;\n    density = 0.8,\n    griddims = (100, 100)\n)\n\nSame as in Forest fire model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.fractal_growth-Tuple{}","page":"Predefined Models","title":"Agents.Models.fractal_growth","text":"fractal_growth(;\n    initial_particles::Int = 100,\n    space_extents::NTuple{2,Float64} = (150.0, 150.0),\n    speed = 0.5,\n    vibration = 0.55,\n    attraction = 0.45,\n    spin = 0.55,\n    clockwise_fraction = 0.0,\n    min_radius = 1.0,\n    max_radius = 2.0,\n)\n\nSame as in Fractal Growth.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.game_of_life-Tuple{}","page":"Predefined Models","title":"Agents.Models.game_of_life","text":"game_of_life(;\n    rules::Tuple = (2, 3, 3, 3),\n    dims = (100, 100),\n    metric = :chebyshev\n)\n\nSame as in Conway's game of life.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.growing_bacteria-Tuple{}","page":"Predefined Models","title":"Agents.Models.growing_bacteria","text":"growing_bacteria()\n\nSame as in Bacterial Growth.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.hk-Tuple{}","page":"Predefined Models","title":"Agents.Models.hk","text":"hk(; \n    numagents = 100, \n    ϵ = 0.2\n)\n\nSame as in HK (Hegselmann and Krause) opinion dynamics model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.opinion-Tuple{}","page":"Predefined Models","title":"Agents.Models.opinion","text":"opinion(;dims=(10, 10), nopinions=3, levels_per_opinion=4)\n\nSame as in Opinion spread.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.predator_prey-Tuple{}","page":"Predefined Models","title":"Agents.Models.predator_prey","text":"predator_prey(;\n    n_sheep = 100,\n    n_wolves = 50,\n    dims = (20, 20),\n    regrowth_time = 30,\n    Δenergy_sheep = 4,\n    Δenergy_wolf = 20,\n    sheep_reproduce = 0.04,\n    wolf_reproduce = 0.05,\n)\n\nSame as in Model of predator-prey dynamics.\n\nTo access the Sheep, Wolf and Grass types, simply call\n\nusing Agents.Models: Sheep, Wolf, Grass\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.schelling-Tuple{}","page":"Predefined Models","title":"Agents.Models.schelling","text":"schelling(;\n    numagents = 320,\n    griddims = (20, 20),\n    min_to_be_happy = 3\n)\n\nSame as in Schelling's segregation model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.social_distancing-Tuple{}","page":"Predefined Models","title":"Agents.Models.social_distancing","text":"social_distancing(;\n    infection_period = 30 * steps_per_day,\n    detection_time = 14 * steps_per_day,\n    reinfection_probability = 0.05,\n    isolated = 0.5, # in percentage\n    interaction_radius = 0.012,\n    dt = 1.0,\n    speed = 0.002,\n    death_rate = 0.044, # from website of WHO\n    N = 1000,\n    initial_infected = 5,\n    seed = 42,\n    βmin = 0.4,\n    βmax = 0.8,\n)\n\nSame as in Continuous space social distancing for COVID-19.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.sugarscape-Tuple{}","page":"Predefined Models","title":"Agents.Models.sugarscape","text":"sugarscape(;\n    dims = (50, 50),\n    sugar_peaks = ((10, 40), (40, 10)),\n    growth_rate = 1,\n    N = 250,\n    w0_dist = (5, 25),\n    metabolic_rate_dist = (1, 4),\n    vision_dist = (1, 6),\n    max_age_dist = (60, 100),\n    max_sugar = 4,\n)\n\nSame as in Sugarscape.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.wealth_distribution-Tuple{}","page":"Predefined Models","title":"Agents.Models.wealth_distribution","text":"wealth_distribution(; \n    dims = (25, 25),\n    wealth = 1,\n    M = 1000\n)\n\nSame as in Wealth distribution model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.wright_fisher-Tuple{}","page":"Predefined Models","title":"Agents.Models.wright_fisher","text":"wright_fisher(; \n    numagents = 100,\n    selection = true\n)\n\nSame as in Wright-Fisher model of evolution.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Agents.jl)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Agents.jl is a pure Julia framework for agent-based modeling (ABM). Agents.jl is part of JuliaDynamics. To get started, please read the Tutorial page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Latest news\nWelcome to Agents.jl v4.0! This new release features improved GridSpace and ContinuousSpace (re-written from scratch), overall performance improvements of Agents.jl of a full order of magnitude (and sometimes more) and re-naming many API functions to make sense (deprecations have been put in place). Have a look at the CHANGELOG for more details!","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Free, open source and extremely transparent.\nIntuitive and simple-to-learn.\nUniversal model structure where agents are identified by a unique id: AgentBasedModel\nPowerful, feature-full and extendable API.\nModular, function-based design.\nSupport for many types of space: arbitrary graphs, regular grids, continuous space, or even instances of Open Street Map.\nMulti-agent support, for interactions between disparate agent species.\nScheduler interface (with default schedulers), making it easy to activate agents in a specific order (e.g. by the value of some property)\nAutomatic data collection in a DataFrame at desired intervals\nAggregating collected data during model evolution\nDistributed computing\nBatch running and batch data collection\nVisualize agent distributions on regular grids or continuous space.\nInteractive applications for any agent based model (in continuous or grid space), which are created with only 5 lines of code and look like this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<video width=\"auto\" controls autoplay loop>\r\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\r\n</video>","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is in Julia's package list. Install it using this command:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"Agents\")","category":"page"},{"location":"#Design-philosophy-of-Agents.jl","page":"Introduction","title":"Design philosophy of Agents.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Agents.jl was designed with the following philosophy in mind:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Simple to learn and use, yet extendable, focusing on fast and scalable model creation and evolution.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(it should be said nevertheless, that when we have to make a choice between a simpler API or a more performant implementation, we tend to lean in favor of simplicity)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are multiple examples that highlight this core design principle, that one will quickly encounter when scanning through our API page. Here we just give two quick examples: first, there exists a universal function nearby_agents, which returns the agents nearby a given agent and within a given \"radius\". What is special for this function, which is allowed by Julia's Multiple Dispatch, is that nearby_agents will work for any space type the model has, reducing the learning curve of finding neighbors in ABMs made with Agents.jl. An even better example is perhaps our treatment of spaces. A user may create an entirely new kind of space (e.g. one representing a planet, or whatever else) by only extending 5 functions, as discussed in our Creating a new space type documentation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Many other agent-based modeling frameworks have been constructed to ease the process of building and analyzing ABMs (see e.g. here for an outdated review), spanning a varying degree of complexity. In the page ABM Framework Comparison we compare how our design philosophy puts us into comparison with other well accepted ABM software. Fascinatingly, even though the main focus of Agents.jl is simplicity and ease of use, it outperforms all software we compared it with.","category":"page"},{"location":"#Crash-course-on-agent-based-modeling","page":"Introduction","title":"Crash course on agent based modeling","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An agent-based (or individual-based) model is a computational simulation of autonomous agents that react to their environment (including other agents) given a predefined set of rules [1]. ABMs have been adopted and studied in a variety of research disciplines. One reason for their popularity is that they enable a relaxation of many simplifying assumptions usually made by mathematical models. Relaxing such assumptions of a \"perfect world\" can change a model's behavior [2].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Agent-based models are increasingly recognized as a useful approach for studying complex systems [3,4,5,6]. Complex systems cannot be fully understood using traditional mathematical tools which aggregate the behavior of elements in a system. The behavior of a complex system depends on both the behavior of and interactions between its elements (agents). Small changes in the input to complex systems or the behavior of its agents can lead to large changes in outcome. That is to say, a complex system's behavior is nonlinear, and that it is not only the sum of the behavior of its elements. Use of ABMs have become feasible after the availability of computers and has been growing ever since, especially in modeling biological and economical systems, and has extended to social studies and archaeology.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An ABM consists of autonomous agents that behave given a set of rules. A classic example of an ABM is Schelling's segregation model, which we implement as an example here. This model uses a regular grid and defines agents at random positions on the grid. Agents can be from different social groups. Agents are happy/unhappy based on the fraction of their neighbors that belong to the same group as they are. If they are unhappy, they keep moving to new locations until they are happy. Schelling's model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods. This is an example of emergent behavior from simple interactions of agents that can only be captured in an agent-based model.","category":"page"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use this package in work that leads to a publication, then please cite the paper below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@misc{Agents.jl,\r\n      title={Agents.jl: A performant and feature-full agent based modelling software of minimal code complexity},\r\n      author={George Datseris and Ali R. Vahdati and Timothy C. DuBois},\r\n      year={2021},\r\n      eprint={2101.10072},\r\n      archivePrefix={arXiv},\r\n      primaryClass={cs.MA}\r\n}","category":"page"},{"location":"devdocs/#Developer-Docs","page":"Developer Docs","title":"Developer Docs","text":"","category":"section"},{"location":"devdocs/#Cloning-the-repository","page":"Developer Docs","title":"Cloning the repository","text":"","category":"section"},{"location":"devdocs/","page":"Developer Docs","title":"Developer Docs","text":"Since we include documentation with many animated gifs and videos in the repository, a standard clone can be larger than expected. If you wish to do any development work, it is better to use","category":"page"},{"location":"devdocs/","page":"Developer Docs","title":"Developer Docs","text":"git clone https://github.com/JuliaDynamics/Agents.jl.git --single-branch","category":"page"},{"location":"devdocs/#Creating-a-new-space-type","page":"Developer Docs","title":"Creating a new space type","text":"","category":"section"},{"location":"devdocs/","page":"Developer Docs","title":"Developer Docs","text":"Creating a new space type within Agents.jl is quite simple and requires the extension of only 5 methods to support the entire Agents.jl API. The exact specifications on how to create a new space type are contained within the file: [src/core/space_interaction_API.jl].","category":"page"},{"location":"devdocs/","page":"Developer Docs","title":"Developer Docs","text":"In principle, the following should be done:","category":"page"},{"location":"devdocs/","page":"Developer Docs","title":"Developer Docs","text":"Think about what the agent position type should be.\nThink about how the space type will keep track of the agent positions, so that it is possible to implement the function nearby_ids.\nImplement the struct that represents your new space, while making it a subtype of AbstractSpace.\nExtend random_position(model).\nThink about how the positions of agents will be updated as agents are moved, added or killed.\nExtend move_agent!(agent, pos, model), add_agent_to_space!(agent, model), remove_agent_from_space!(agent, model).\nExtend nearby_ids(position, model, r).","category":"page"},{"location":"devdocs/","page":"Developer Docs","title":"Developer Docs","text":"And that's it!","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Agents.jl structures ABM simulations following the following simple mental model:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, the user needs to define the agent type (or types, for mixed models) that will populate the ABM. This is defined as a standard Julia Type.\nThen, the user needs to choose in what kind of space these agents will live in, for example a graph, a grid, etc. Several spaces are provided by Agents.jl and can be initialized immediately.\nThe created agent type, the chosen space, additional model level properties (typically in the form of a dictionary), and a scheduler (a standard Julia function, with several default ones available), are provided in our universal structure AgentBasedModel. This instance defines the model within an Agents.jl simulation.\nSimulations in Agents.jl happen in discrete and individual steps. To evolve the model in time the user needs to define one, or two, stepping functions that control how the agents and the model should evolve. These are standard Julia functions that take advantage of the Agents.jl API.\nTo collect data during time evolution, the user needs to specify which data should be collected, by providing one standard Julia Vector of data-to-collect for agents, and another one for the model. The outputted data are in the form of a DataFrame.","category":"page"},{"location":"tutorial/#.-The-agent-type","page":"Tutorial","title":"1. The agent type","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AbstractAgent","category":"page"},{"location":"tutorial/#Agents.AbstractAgent","page":"Tutorial","title":"Agents.AbstractAgent","text":"YourAgentType <: AbstractAgent\n\nAgents participating in Agents.jl simulations are instances of user-defined Types that are subtypes of AbstractAgent. It is almost always the case that mutable Types make for a simpler modellign experience.\n\nYour agent type(s) must have the id field as first field. Depending on the space structure there might be a pos field of appropriate type and a vel field of appropriate type. Each space structure quantifies precicely what extra fields (if any) are necessary, however we recommend to use the @agent macro to help you create the agent type.\n\nYour agent type may have other additional fields relevant to your system, for example variable quantities like \"status\" or other \"counters\".\n\nAs an example, a GraphSpace requires an id::Int field and a pos::Int field. To make an agent with two additional properties, weight, happy, we'd write\n\nmutable struct ExampleAgent <: AbstractAgent\n    id::Int\n    pos::Int\n    weight::Float64\n    happy::Bool\nend\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once an Agent is created it can be added to a model using e.g. add_agent!. Then, the agent can interact with the model and the space further by using e.g. move_agent! or kill_agent!.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For more functions visit the API page.","category":"page"},{"location":"tutorial/#Space","page":"Tutorial","title":"2. The space","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Agents.jl offers several possibilities for the space the agents live in. In addition, it is straightforward to implement a fundamentally new type of space, see Developer Docs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The available spaces are:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GraphSpace: Agent positions are equivalent with nodes of a graph/network.\nGridSpace: Space is discretized into boxes, typical style for cellular automata.\nContinuousSpace: Truthful representation of continuous space, regarding location, orientation, and identification of neighboring agents.\nOpenStreetMapSpace: A space based on Open Street Map, where agents are confined to move along streets of the map, using real-world meter values for the length of each street.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One simply initializes an instance of a space, e.g. with grid = GridSpace((10, 10)) and passes that into AgentBasedModel. See each individual space for all its possible arguments.","category":"page"},{"location":"tutorial/#.-The-model","page":"Tutorial","title":"3. The model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AgentBasedModel","category":"page"},{"location":"tutorial/#Agents.AgentBasedModel","page":"Tutorial","title":"Agents.AgentBasedModel","text":"AgentBasedModel(AgentType [, space, pathfinder]; scheduler, properties) → model\n\nCreate an agent based model from the given agent type and space. You can provide an agent instance instead of type, and the type will be deduced. ABM is equivalent with AgentBasedModel.\n\nThe agents are stored in a dictionary that maps unique IDs (integers) to agents. Use model[id] to get the agent with the given id.\n\nspace is a subtype of AbstractSpace, see Space for all available spaces. If it is ommited then all agents are virtually in one position and have no spatial structure.\n\nNote: Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.\n\npathfinder TODO\n\nproperties = nothing is additional model-level properties (typically a dictionary) that can be accessed as model.properties. If properties is a dictionary with key type Symbol, or of it is a struct, then the syntax model.name is short hand for model.properties[:name] (or model.properties.name for structs). This syntax can't be used for name being agents, space, scheduler, properties, rng, maxid, which are the fields of AgentBasedModel.\n\nscheduler = fastest decides the order with which agents are activated (see e.g. by_id and the scheduler API). scheduler is only meaningful if an agent-stepping function is defined for step! or run!.\n\nrng = Random.default_rng() provides random number generation to the model. Accepts any subtype of AbstractRNG and is accessed by model.rng.\n\nType tests for AgentType are done, and by default warnings are thrown when appropriate. Use keyword warn=false to suppress that.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#.-Evolving-the-model","page":"Tutorial","title":"4. Evolving the model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any ABM model should have at least one and at most two step functions. An agent step function is required by default. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a model step function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An agent step function should only accept two arguments: first, an agent object, and second, a model object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in dummystep as the agent step function. This is typically the case for Advanced stepping.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After you have defined these two functions, you evolve your model with step!:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"step!\ndummystep","category":"page"},{"location":"tutorial/#Agents.dummystep","page":"Tutorial","title":"Agents.dummystep","text":"dummystep(model)\n\nUse instead of model_step! in step! if no function is useful to be defined.\n\n\n\n\n\ndummystep(agent, model)\n\nUse instead of agent_step! in step! if no function is useful to be defined.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Current step number\nNotice that the current step number is not explicitly given to the model_step! function, because this is useful only for a subset of ABMs. If you need the step information, implement this by adding a counting parameter into the model properties, and incrementing it by 1 each time model_step! is called. An example can be seen in the model_step! function of Daisyworld, where a tick is increased at each step.","category":"page"},{"location":"tutorial/#Advanced-stepping","page":"Tutorial","title":"Advanced stepping","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface of step!, which allows the option of both agent_step! and model_step! is driven mostly by convenience. In principle, the model_step! function by itself can perform all operations related with stepping the ABM. However, for many models, this simplified approach offers the benefit of not having to write an explicit loop over existing agents inside the model_step!. Most of the examples in our documentation can be expressed using an independent agent_step! and model_step! function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"On the other hand, more advanced models require special handling for scheduling, or may need to schedule several times and act on different subsets of agents with different functions. In such a scenario, it is more sensible to provide only a model_step! function (and use dummystep as agent_step!), where all configuration is contained within. Notice that if you follow this road, the argument scheduler given to AgentBasedModel somewhat loses its meaning.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here is an example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function complex_step!(model)\n    for a in scheduler1(model)\n        agent_step1!(a, model)\n    end\n    intermediate_model_action!(model)\n    for a in scheduler2(model)\n        agent_step2!(a, model)\n    end\n    final_model_action!(model)\nend\n\nstep!(model, dummystep, complex_step!, n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For defining your own schedulers, see Schedulers.","category":"page"},{"location":"tutorial/#.-Collecting-data","page":"Tutorial","title":"5. Collecting data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Running the model and collecting data while the model runs is done with the run! function. Besides run!, there is also the paramscan function that performs data collection, while scanning ranges of the parameters of the model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"run!","category":"page"},{"location":"tutorial/#Agents.run!","page":"Tutorial","title":"Agents.run!","text":"run!(model, agent_step! [, model_step!], n::Integer; kwargs...) → agent_df, model_df\nrun!(model, agent_step!, model_step!, n::Function; kwargs...) → agent_df, model_df\n\nRun the model (step it with the input arguments propagated into step!) and collect data specified by the keywords, explained one by one below. Return the data as two DataFrames, one for agent-level data and one for model-level data.\n\nData-deciding keywords\n\nadata::Vector means \"agent data to collect\". If an entry is a Symbol, e.g. :weight, then the data for this entry is agent's field weight. If an entry is a Function, e.g. f, then the data for this entry is just f(a) for each agent a. The resulting dataframe columns are named with the input symbol (here :weight, :f).\nadata::Vector{<:Tuple}: if adata is a vector of tuples instead, data aggregation is done over the agent properties.\nFor each 2-tuple, the first entry is the \"key\" (any entry like the ones mentioned above, e.g. :weight, f). The second entry is an aggregating function that aggregates the key, e.g. mean, maximum. So, continuing from the above example, we would have adata = [(:weight, mean), (f, maximum)].\nIt's also possible to provide a 3-tuple, with the third entry being a conditional function (returning a Bool), which assesses if each agent should be included in the aggregate. For example: x_pos(a) = a.pos[1]>5 with (:weight, mean, x_pos) will result in the average weight of agents conditional on their x-position being greater than 5.\nThe resulting data name columns use the function aggname, and create something like :mean_weight or :maximum_f_x_pos. This name doesn't play well with anonymous functions, but you can simply use DataFrames.rename! to change the returned dataframe's column names.\nNotice: Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. E.g. instead of passing mean, pass mymean(a) = isempty(a) ? 0.0 : mean(a).\nmdata::Vector means \"model data to collect\" and works exactly like adata. For the model, no aggregation is possible (nothing to aggregate over).\n\nBy default both keywords are nothing, i.e. nothing is collected/aggregated.\n\nMixed-Models\n\nFor mixed-models, the adata keyword has some additional options & properties.   An additional column agent_type will be placed in the output   dataframe.\n\nIn the case that data is needed for one agent type that does not exist   in a second agent type, missing values will be added to the dataframe.\n\nWarning: Since this option is inherently type unstable, try to avoid this   in a performance critical situation.\n\nAggregate functions will fail if missing values are not handled explicitly.   If a1.weight but a2 (type: Agent2) has no weight, use   a2(a) = a isa Agent2; adata = [(:weight, sum, a2)] to filter out the missing results.\n\nOther keywords\n\nwhen=true : at which steps s to perform the data collection and processing. A lot of flexibility is offered based on the type of when. If when::Vector, then data are collect if s ∈ when. Otherwise data are collected if when(model, s) returns true. By default data are collected in every step.\nwhen_model = when : same as when but for model data.\nobtainer = identity : method to transfer collected data to the DataFrame. Typically only change this to copy if some data are mutable containers (e.g. Vector) which change during evolution, or deepcopy if some data are nested mutable containers. Both of these options have performance penalties.\nreplicates=0 : Run replicates replicates of the simulation.\nparallel=false : Only when replicates>0. Run replicate simulations in parallel.\nagents_first=true : Whether to update agents first and then the model, or vice versa.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The run! function has been designed for maximum flexibility: nearly all scenarios of data collection are possible whether you need agent data, model data, aggregating model data, or arbitrary combinations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This means that run! has not been designed for maximum performance (or minimum memory allocation). However, we also expose a simple data-collection API (see Data collection), that gives users even more flexibility, allowing them to make their own \"data collection loops\" arbitrarily calling step! and collecting data as, and when, needed.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As your models become more complex, it may not be advantageous to use lots of helper functions in the global scope to assist with data collection. If this is the case in your model, here's a helpful tip to keep things clean:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function assets(model)\n    total_savings(model) = model.bank_balance + sum(model.assets)\n    function stategy(model)\n        if model.year == 0\n            return model.initial_strategy\n        else\n            return get_strategy(model)\n        end\n    end\n    return [:age, :details, total_savings, strategy]\nend\nrun!(model, agent_step!, model_step!, 10; mdata = assets(model))","category":"page"},{"location":"tutorial/#Seeding-and-Random-numbers","page":"Tutorial","title":"Seeding and Random numbers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Each model created by AgentBasedModel provides a random number generator pool model.rng which by default coincides with the global RNG. For performance reasons, one should never use rand() without using a pool, thus throughout our examples we use rand(model.rng) or rand(model.rng, 1:10, 100), etc.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Another benefit of this approach is can have deterministic models that can be ran again and yield the same output. To do this, either always pass a specifically seeded RNG to the model creation, e.g. MersenneTwister(1234), or call seed!(model, 1234) (with any number) after creating the model but before actually running the simulation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Passing RandomDevice() will use the system's entropy source (coupled with hardware like TrueRNG will invoke a true random source, rather than pseudo-random methods like MersenneTwister). Models using this method cannot be repeatable, but avoid potential biases of pseudo-randomness.","category":"page"},{"location":"tutorial/#An-educative-example","page":"Tutorial","title":"An educative example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A simple, education-oriented example of using the basic Agents.jl API is given in Schelling's segregation model, also discussing in detail how to visualize your ABMs. For a quick reference concerning the main concepts of agent based modelling, and how the Agents.jl examples implement each one, take a look at the Overview of Examples page.","category":"page"}]
}
